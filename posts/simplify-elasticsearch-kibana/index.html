<!doctype html><html class=dark lang=en><head><meta charset=UTF-8><meta content="width=device-width,initial-scale=1.0" name=viewport><title>Simplify Elasticsearch and Kibana Installation</title><meta content="Simplify Elasticsearch and Kibana Installation" property=og:title><meta content="Let me walk you through how I created a bash script that sets up Elasticsearch and Kibana on a single-node cluster with minimal fuss." property=og:description><meta content="Let me walk you through how I created a bash script that sets up Elasticsearch and Kibana on a single-node cluster with minimal fuss." name=description><link href=https://svnscha.de/posts/simplify-elasticsearch-kibana/ rel=canonical><link href=/favicon.ico rel=icon type=image/png><link href=/apple-touch-icon.png rel=apple-touch-icon sizes=180x180><link href=/favicon-32x32.png rel=icon sizes=32x32 type=image/png><link href=/favicon-16x16.png rel=icon sizes=16x16 type=image/png><link href=/site.webmanifest rel=manifest><link href=https://svnscha.de/fonts.css rel=stylesheet><script>var _paq=window._paq=window._paq||[];_paq.push(['disableCookies']);_paq.push(['trackPageView']);_paq.push(['enableLinkTracking']);_paq.push(['enableHeartBeatTimer']);(function(){var a="//analytics.liasoft.de/";_paq.push(['setTrackerUrl',a+ 'matomo.php']);_paq.push(['setSiteId','27']);var b=document,c=b.createElement('script'),d=b.getElementsByTagName('script')[0];c.async=true;c.src=a+ 'matomo.js';d.parentNode.insertBefore(c,d)})()</script><link href=https://svnscha.de/atom.xml rel=alternate title=svnscha type=application/atom+xml><link href=https://svnscha.de/theme/dark.css rel=stylesheet><link href=https://svnscha.de/main.css media=screen rel=stylesheet><link href=https://svnscha.de/lightbox.css rel=stylesheet><body><div class=content><header><style>.avatar{vertical-align:middle;width:150px;height:150px;border-radius:50%}#wrapper{width:100%;clear:both;text-align:center}</style><div class=main><a href=https://svnscha.de title=svnscha>svnscha</a><div class=socials><a class=social href=https://www.linkedin.com/in/svnscha/ rel=me> <img alt=linkedin src=/social_icons/linkedin.svg> </a><a class=social href=https://github.com/svnscha/ rel=me> <img alt=github src=/social_icons/github.svg> </a></div></div><nav><a href=/about style=margin-left:.7em>/about</a><a href=/notes style=margin-left:.7em>/notes</a></nav><div id=wrapper><a href=https://svnscha.de title=svnscha> <img alt="svnscha - Profile Picture" class=avatar src=/svnscha.webp> </a></div></header><main><article><div class=title><h1 class=page-header>Simplify Elasticsearch and Kibana Installation</h1><div class=meta>Posted on <time>2024-04-24</time></div></div><section class=body><h2 id=why-you-ask>Why, You Ask?</h2><p>Every time I set up a new instance of Elasticsearch and Kibana, the repetitive steps grated on me. Updating the system, configuring repositories, installing packages... surely there's a better way? And thus, the quest for automation began. Not only to save my own time but to provide a robust foundation for others in the community facing the same tedious setup.<p><strong>It's time-consuming and frustrating. I'm tired of it.</strong><h2 id=automating-elasticsearch-and-kibana-setup-a-journey-to-simplicity>Automating Elasticsearch and Kibana Setup: A Journey to Simplicity</h2><p>In our ever-expanding digital landscape, data is no longer just a resource; it's an entire ecosystem. Managing this ecosystem efficiently requires robust tools like Elasticsearch and Kibana. But let's be honest, the setup can be a drag! Inspired by my own need for simplification and a love for automating mundane tasks, I embarked on a journey to streamline this setup process. Let me walk you through how I created a bash script that sets up Elasticsearch and Kibana on a single-node cluster with minimal fuss.<h2 id=why-choose-a-bash-script>Why Choose a Bash Script?</h2><p>You might be wondering why I opted for a Bash script over more sophisticated tools like Ansible. Well, the answer is straightforward: I appreciate simplicity. Bash scripts are incredibly versatile—perfect for cloud-init scripts in my homelab or even within Docker environments. This approach keeps things simple, avoiding the need for extra tools or complexities. It's just easier that way!<h2 id=building-the-script-a-step-by-step-guide>Building the Script: A Step-by-Step Guide</h2><p>Let's walk through the crafting of the script that automates setting up Elasticsearch and Kibana. Here's how I pieced it together, one step at a time:<ol><li>Checking for Superuser Privileges Every great adventure starts with a little bit of power. What's more powerful than starting off with full system access?</ol><pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#c678dd>if </span><span style=color:#56b6c2>[ </span><span style=color:#98c379>"$(</span><span style=color:#e06c75>id -u</span><span style=color:#98c379>)" </span><span>!= </span><span style=color:#98c379>"0" </span><span style=color:#56b6c2>]</span><span>; </span><span style=color:#c678dd>then
</span><span>   </span><span style=color:#56b6c2>echo </span><span style=color:#98c379>"This script must be run as root" </span><span style=color:#d19a66>1</span><span>>&</span><span style=color:#d19a66>2
</span><span>   </span><span style=color:#56b6c2>exit</span><span> 1
</span><span style=color:#c678dd>fi
</span></code></pre><ol start=2><li>Updating the System and Installing Essential Packages Think of this as prepping your car before a long road trip. A well-oiled machine avoids breakdowns, and that's exactly what we're aiming for—no surprises!</ol><pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#e06c75>apt</span><span> update
</span><span style=color:#e06c75>apt</span><span> install</span><span style=color:#e06c75> -y</span><span> apt-transport-https gnupg curl jq
</span></code></pre><ol start=3><li><p>Adding the Elasticsearch Repository Getting this right is like picking the perfect ingredients for a master chef recipe—it ensures the rest of the meal turns out just right.</p><li><p>Installing Elasticsearch and Kibana This is where the transformation happens. What was once a bare-metal server soon becomes a powerful tool capable of sifting through vast amounts of data.</p><li><p>Configuring and Starting Services The plot thickens! Setting up the services and getting them running is like reaching the climax of our story—where all elements come together to unveil the full potential of our setup.</p></ol><p>Rather than churn out another cookie-cutter guide on setting up Elasticsearch and Kibana, you can view the complete script <a href=https://gist.github.com/svnscha/676291c9e1cdbfa261202b3897afba37>here</a>. However, I do want to emphasize the initial configuration process involving enrollment tokens and security settings. I've automated these aspects because, let's face it, I've read too many guides that suggest just turning off security for the sake of simplicity. That's not my style—I'd rather keep things secure automatically. It's not rocket science, but it sure is critical. Why simplify by compromising security when you can automate it effectively, right?<p>This approach ensures you get the functionality you need without the hassle of manual setup or the risks of disabled security.<h2 id=perfecting-the-automation-securing-and-finalizing-the-setup>Perfecting the Automation: Securing and Finalizing the Setup</h2><p>As we approach the climax of our automation journey, it's all about ensuring that our Elasticsearch and Kibana setup not only functions but is also secured and ready for action. This part of the script is where the real magic happens—turning a fresh install into a secured and operational data exploration environment.<ol><li>Broadcasting the Good News First things first, let's make sure any user logging into the system knows what's been accomplished:</ol><pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-e </span><span style=color:#98c379>"=== init-vm.sh: Initial ===" </span><span>>> /etc/motd
</span><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-e </span><span style=color:#98c379>"[> Elasticsearch 'elastic' password: $</span><span style=color:#e06c75>ELASTIC_PASSWORD</span><span style=color:#98c379>" </span><span>>> /etc/motd
</span><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-e </span><span style=color:#98c379>"[> Test instance with 'curl -k -X GET https://elastic:$</span><span style=color:#e06c75>ELASTIC_PASSWORD</span><span style=color:#98c379>@localhost:9200'" </span><span>>> /etc/motd
</span><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-e </span><span style=color:#98c379>"=== init-vm.sh: Get started ===" </span><span>>> /etc/motd
</span><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-e </span><span style=color:#98c379>"[> Reset 'elastic' password with '/usr/share/elasticsearch/bin/elasticsearch-reset-password -u elastic'." </span><span>>> /etc/motd
</span><span>
</span></code></pre><p>Here, we're updating the message of the day (MOTD) file to ensure anyone who logs in is immediately informed about how to interact with Elasticsearch and what steps to take next. It's like leaving a note on the fridge - impossible to ignore and incredibly helpful.<ol start=2><li>Decoding the Secrets Automation isn't just about doing things without human intervention; it's also about doing them securely and wisely:</ol><pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=font-style:italic;color:#5c6370># Because who likes doing setup manually, right?
</span><span style=color:#e06c75>decoded_token</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#98c379>$</span><span style=color:#e06c75>KIBANA_ENROLLMENT_TOKEN </span><span>| </span><span style=color:#e06c75>base64 --decode</span><span style=color:#98c379>)
</span><span style=color:#e06c75>address</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#98c379>$</span><span style=color:#e06c75>decoded_token </span><span>| </span><span style=color:#e06c75>jq -r </span><span style=color:#98c379>'.adr[0]')
</span><span style=color:#e06c75>fingerprint</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#98c379>$</span><span style=color:#e06c75>decoded_token </span><span>| </span><span style=color:#e06c75>jq -r </span><span style=color:#98c379>'.fgr')
</span><span style=color:#e06c75>api_key</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#98c379>$</span><span style=color:#e06c75>decoded_token </span><span>| </span><span style=color:#e06c75>jq -r </span><span style=color:#98c379>'.key')
</span></code></pre><p>Decoding the enrollment token reveals the essential elements needed to securely configure Kibana: the address, fingerprint, and API key.<p>Harnessing Version and Build Information Knowing exactly which version and build of Kibana you're working with is required for the API, so let's get that:<pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#e06c75>ver</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#e06c75>jq -r </span><span style=color:#98c379>'.version' /usr/share/kibana/package.json)
</span><span style=color:#e06c75>build</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#e06c75>jq -r </span><span style=color:#98c379>'.build.number' /usr/share/kibana/package.json)
</span></code></pre><ol start=3><li>Re-encoding and Verification Secrecy is paramount, and so is verification. Here's how we handle both:</ol><pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#e06c75>encoded_api_key</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#e06c75>-n </span><span style=color:#98c379>$</span><span style=color:#e06c75>api_key </span><span>| </span><span style=color:#e06c75>base64</span><span style=color:#98c379>)
</span><span style=color:#e06c75>output</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#e06c75>sudo</span><span style=color:#98c379> /usr/share/kibana/bin/kibana-verification-code)
</span><span style=color:#e06c75>verification_code</span><span>=</span><span style=color:#98c379>$(</span><span style=color:#56b6c2>echo </span><span style=color:#98c379>$</span><span style=color:#e06c75>output </span><span>| </span><span style=color:#e06c75>awk -F</span><span style=color:#98c379>": " '{print $2}' </span><span>| </span><span style=color:#e06c75>sed </span><span style=color:#98c379>'s/ //g')
</span></code></pre><p>The API key needs to be re-encoded to maintain security, and we also extract a verification code necessary for the next step—enrolling Kibana.<h2 id=the-final-act-enrolling-kibana>The Final Act: Enrolling Kibana</h2><p>And now, the final piece of our automation puzzle:<pre class=language-bash data-lang=bash style=background:#282c34;color:#abb2bf><code class=language-bash data-lang=bash><span style=color:#e06c75>curl -k -v -X</span><span> POST </span><span style=color:#98c379>"http://localhost:5601/internal/interactive_setup/enroll" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"Accept: */*" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"Content-Type: application/json" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"Host: localhost:5601" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"Origin: http://localhost:5601" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"Referer: http://localhost:5601/" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"kbn-build-number: $</span><span style=color:#e06c75>build</span><span style=color:#98c379>" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"kbn-version: $</span><span style=color:#e06c75>ver</span><span style=color:#98c379>" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"x-elastic-internal-origin: Kibana" </span><span>\
</span><span style=color:#e06c75>     -H </span><span style=color:#98c379>"x-kbn-context: %7B%22type%22%3A%22application%22%2C%22name%22%3A%22interactiveSetup%22%2C%22url%22%3A%22%2F%22%7D" </span><span>\
</span><span style=color:#e06c75>     -d </span><span style=color:#98c379>'{"hosts":["https://'</span><span>$</span><span style=color:#e06c75>address</span><span style=color:#98c379>'"],"apiKey":"'</span><span>$</span><span style=color:#e06c75>encoded_api_key</span><span style=color:#98c379>'","caFingerprint":"'</span><span>$</span><span style=color:#e06c75>fingerprint</span><span style=color:#98c379>'","code":"'</span><span>$</span><span style=color:#e06c75>verification_code</span><span style=color:#98c379>'"}'
</span></code></pre><p>This curl command not only sends all the needed parameters to Kibana for configuration but also uses the verification code to ensure that the setup is both authorized and secure. It's akin to dotting the i's and crossing the t's in our setup script.<h3 id=wrapping-up>Wrapping Up</h3><p>From the mundane to the technical, every line of code we've added builds towards making Elasticsearch and Kibana not just operational but secured and ready for whatever data you throw at it. Feel free to dive into the full script, tweak it, use it, and share it. After all, isn't the whole point of automation to make life a bit easier?<p>Check out the complete script here:<ul><li><a href=https://gist.github.com/svnscha/676291c9e1cdbfa261202b3897afba37>init-elastic-search-kibana-vm.sh</a></ul><p>Happy automating, and here's to many insightful data explorations!<p>P.S.: This script is tailored for automating development environments. Remember, a single-node cluster isn’t suited for production use, and storing passwords in the message of the day (MOTD) file? That’s a no-go for serious deployments. 😏</section></article></main><hr><center><small>Copyright © 2025 Sven Scharmentke. All rights reserved.</small></center></div><script src=https://svnscha.de/lightbox.js></script>